% 8-Puzzle solver using DFS and IDS

% Start state (replace with your puzzle)
start(state(6,1,3,
            4,*,5,
            7,2,0)).

% Goal state
goal(state(*,0,1,
           2,3,4,
           5,6,7)).

% Moves: move the blank (*) left, right, up, down
move(state(,B,C,D,E,F,G,H,I), state(B,,C,D,E,F,G,H,I), right).
move(state(,B,C,D,E,F,G,H,I), state(D,B,C,,E,F,G,H,I), down).

move(state(A,,C,D,E,F,G,H,I), state(,A,C,D,E,F,G,H,I), left).
move(state(A,,C,D,E,F,G,H,I), state(A,C,,D,E,F,G,H,I), right).
move(state(A,,C,D,E,F,G,H,I), state(A,E,C,D,,F,G,H,I), down).

move(state(A,B,,D,E,F,G,H,I), state(A,,B,D,E,F,G,H,I), left).
move(state(A,B,,D,E,F,G,H,I), state(A,B,F,D,E,,G,H,I), down).

move(state(A,B,C,,E,F,G,H,I), state(,B,C,A,E,F,G,H,I), up).
move(state(A,B,C,,E,F,G,H,I), state(A,B,C,E,,F,G,H,I), right).
move(state(A,B,C,,E,F,G,H,I), state(A,B,C,G,E,F,,H,I), down).

move(state(A,B,C,D,,F,G,H,I), state(A,,C,D,B,F,G,H,I), up).
move(state(A,B,C,D,,F,G,H,I), state(A,B,C,D,F,,G,H,I), right).
move(state(A,B,C,D,,F,G,H,I), state(A,B,C,D,H,F,G,,I), down).
move(state(A,B,C,D,,F,G,H,I), state(A,B,C,,D,F,G,H,I), left).

move(state(A,B,C,D,E,,G,H,I), state(A,B,,D,E,C,G,H,I), up).
move(state(A,B,C,D,E,,G,H,I), state(A,B,C,D,,E,G,H,I), left).
move(state(A,B,C,D,E,,G,H,I), state(A,B,C,D,E,I,G,H,), down).

move(state(A,B,C,D,E,F,,H,I), state(A,B,C,D,E,F,H,,I), left).
move(state(A,B,C,D,E,F,,H,I), state(A,B,C,D,,E,F,H,I), up).

move(state(A,B,C,D,E,F,G,,I), state(A,B,C,D,E,F,,G,I), left).
move(state(A,B,C,D,E,F,G,,I), state(A,B,C,D,,F,G,E,I), up).
move(state(A,B,C,D,E,F,G,,I), state(A,B,C,D,E,F,G,I,), right).

move(state(A,B,C,D,E,F,G,H,), state(A,B,C,D,E,,G,H,F), up).
move(state(A,B,C,D,E,F,G,H,), state(A,B,C,D,E,F,G,,H), left).

% DFS base case: goal reached
dfs([State|States], [], Path) :-
    goal(State),
    !,
    reverse([State|States], Path).

% DFS recursive case: explore moves
dfs([State|States], [Move|Moves], Path) :-
    move(State, Next, Move),
    \+ memberchk(Next, [State|States]),  % prevent cycles
    dfs([Next,State|States], Moves, Path).

% Show the moves and states nicely
show([], _).
show([Move|Moves], [State|States]) :-
    State = state(A,B,C,D,E,F,G,H,I),
    format('~nMove: ~w~n~n', [Move]),
    format('~w ~w ~w~n', [A,B,C]),
    format('~w ~w ~w~n', [D,E,F]),
    format('~w ~w ~w~n', [G,H,I]),
    show(Moves, States).

% Iterative deepening search
ids :-
    start(State),
    between(0, 100, Depth),   % max depth limit (adjust as needed)
    length(Moves, Depth),
    dfs([State], Moves, Path),
    !,
    show([start|Moves], Path),
    format('~nmoves = ~w~n', [Depth]).

# [eight_puzzle]
ids.

Move: start

6 1 3
4 * 5
7 2 0

Move: down

6 1 3
4 2 5
7 * 0

Move: left

6 1 3
4 2 5
* 7 0

Move: up

6 1 3
4 * 2
5 7 0

Move: right

6 1 3
4 2 *
5 7 0

Move: up

6 1 *
4 2 3
5 7 0

Move: left

6 * 1
4 2 3
5 7 0

Move: down

6 2 1
4 * 3
5 7 0

Move: right

6 2 1
4 3 *
5 7 0

Move: down

6 2 1
4 3 0
5 7 *

Move: left

6 2 1
4 3 0
5 * 7

Move: left

6 2 1
4 3 0
* 5 7

Move: up

6 2 1
4 * 3
0 5 7

Move: left

6 2 1
* 4 3
0 5 7

Move: down

6 2 1
0 4 3
* 5 7

Move: up

6 2 1
0 * 4
3 5 7

Move: left

6 2 1
* 0 4
3 5 7

Move: up

* 2 1
6 0 4
3 5 7

Move: right

2 * 1
6 0 4
3 5 7

Move: down

2 0 1
6 * 4
3 5 7

Move: left

2 0 1
* 6 4
3 5 7

Move: down

2 0 1
3 6 4
* 5 7

Move: left

2 0 1
3 6 4
5 * 7

Move: up

2 0 1
3 * 4
5 6 7

Move: left

2 0 1
* 3 4
5 6 7

Move: up

* 0 1
2 3 4
5 6 7

moves = 25
true.
